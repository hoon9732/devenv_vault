{
  "sessionId": "fd856a38-f736-4224-8355-610b63574668",
  "projectHash": "4922afec48a6aa7def962fe51091816681e0674fcf818a9b9da59d1048ff882c",
  "startTime": "2025-09-26T05:39:29.391Z",
  "lastUpdated": "2025-09-26T05:41:35.948Z",
  "messages": [
    {
      "id": "5caac6dd-52b7-4903-b051-3715a90ce3f5",
      "timestamp": "2025-09-26T05:39:29.391Z",
      "type": "user",
      "content": "#explain @mtsc/app/SdlcRecvGcu.c\n--- Content from referenced files ---\nContent from @C:\\Users\\USER\\Documents\\code\\mtsc\\app\\SdlcRecvGcu.c:\n#define DEBUG_MSG\r\n\r\n#include <eventLib.h>\r\n#include <msgQEvLib.h>\r\n#include <semEvLib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n#include \"../lib/util/isDebug.h\"\r\n#include \"../drv/axiSdlc.h\"\r\n#include \"typeDef/opsType.h\"\r\n#include \"common.h\"\r\n#include \"SdlcRecvGcu.h\"\r\n#include \"LogSend.h\"\r\n#include \"SdlcSwap.h\"\r\n#include \"tickLib.h\"\r\n#include \"Monitoring.h\"\r\n\r\n#define SDLC_RECV_GCU_MSG_Q_LEN\t\t(20)\r\n#define SDLC_RECV_GCU_EVENT_SDLC\t(VXEV01)\r\n#define SDLC_RECV_GCU_EVENT_CMD\t\t(VXEV02)\r\n#define SDLC_RECV_GCU_EVENTS \\\r\n\t(SDLC_RECV_GCU_EVENT_SDLC | SDLC_RECV_GCU_EVENT_CMD)\r\n\t\r\n#define NAV_VE_TOLERANCE\t\t\t(0.5)\r\n#define NAV_VN_TOLERANCE\t\t\t(0.5)\r\n#define NAV_VU_TOLERANCE\t\t\t(0.5)\r\n#define NAV_ALAT_TOLERANCE\t\t\t(30.0)\r\n#define NAV_ALONG_TOLERANCE\t\t\t(30.0)\r\n#define NAV_AHEIGHT_TOLERANCE\t\t(60.0)\r\n\r\n#define  SDLC_RECV_GCU_SDLC_CH\t\t(0)\r\n\r\ntypedef enum {\r\n\tRUNNING,\r\n\tSTOP\r\n} SdlcRecvGcuState;\r\n\r\ntypedef struct {\r\n\tTASK_ID\t\t\ttaskId;\r\n\tModuleType\t\tipcType;\r\n\tunion {\r\n\t\tMSG_Q_ID\tmsgQId;\r\n\t\tint\t\t\tpipeFd;\r\n\t\tint\t\t\tquitFlag;\r\n\t} ipcObj;\r\n\tchar\t\t\tdeferredWorkName[32];\r\n#ifdef USE_CHK_TASK_STATUS\r\n\tTaskStatus *\t\ttaskStatus;\r\n#endif\r\n\tSdlcRecvGcuState\tstate;\r\n\tSEM_ID\t\t\t\tsidSdlcRx;\r\n} SdlcRecvGcuInst;\r\n\r\nLOCAL SdlcRecvGcuInst g_stSdlcRecvGcuInst = {\r\n\tTASK_ID_ERROR, MSGQ, {MSG_Q_ID_NULL}, \"\",\r\n};\r\n\r\nLOCAL TM_TYPE_SDLC_RX\tg_stSdlcRxBuf;\r\nLOCAL UINT32\t\t\tg_nSdlcRxSize;\r\n\r\nLOCAL LOG_DATA\t\t\tg_tmGf2Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf3Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf5Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf6Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf7Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf8Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf9Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf11Log;\r\nLOCAL LOG_DATA\t\t\tg_tmGf12Log;\r\n\r\nLOCAL LOG_DATA\t\t\tg_monNavLog;\r\n\r\nconst ModuleInst *g_hSdlcRecvGcu = (ModuleInst *)&g_stSdlcRecvGcuInst;\r\n\r\nTM_TYPE_SDLC_TX * g_pTmSdlcGfRx = &g_stSdlcRxBuf;\r\nTM_TYPE_GF2 * g_pTmGf2 = &g_tmGf2Log.formatted.body.sdlcRx.gf2;\r\nTM_TYPE_GF3 * g_pTmGf3 = &g_tmGf3Log.formatted.body.sdlcRx.gf3;\r\nTM_TYPE_GF5 * g_pTmGf5 = &g_tmGf5Log.formatted.body.sdlcRx.gf5;\r\nTM_TYPE_GF6 * g_pTmGf6 = &g_tmGf6Log.formatted.body.sdlcRx.gf6;\r\nTM_TYPE_GF7 * g_pTmGf7 = &g_tmGf7Log.formatted.body.sdlcRx.gf7;\r\nTM_TYPE_GF8 * g_pTmGf8 = &g_tmGf8Log.formatted.body.sdlcRx.gf8;\r\nTM_TYPE_GF8 * g_pTmGf9 = &g_tmGf9Log.formatted.body.sdlcRx.gf9;\r\nTM_TYPE_GF11 * g_pTmGf11 = &g_tmGf11Log.formatted.body.sdlcRx.gf11;\r\nTM_TYPE_GF12 * g_pTmGf12 = &g_tmGf12Log.formatted.body.sdlcRx.gf12;\r\n\r\nMonitoringNavLog * g_pMonNav = &g_monNavLog.formatted.body.monitoringNav;\r\n\r\nLOCAL STATUS\tInitSdlcRecvGcu(SdlcRecvGcuInst *this);\r\nLOCAL STATUS\tFinalizeSdlcRecvGcu(SdlcRecvGcuInst *this);\r\nLOCAL STATUS\tExecuteSdlcRecvGcu(SdlcRecvGcuInst *this);\r\n\r\nLOCAL void\t\tOnStart(SdlcRecvGcuInst *this);\r\nLOCAL void\t\tOnStop(SdlcRecvGcuInst *this);\r\nLOCAL STATUS\tOnInitRxFrames(SdlcRecvGcuInst *this);\r\n\r\nLOCAL STATUS \tprocCommand(SdlcRecvGcuInst *this);\r\nLOCAL STATUS\tprocSdlc(SdlcRecvGcuInst *this);\r\n\r\nLOCAL STATUS\thandleSdlcRxBuf(void);\r\nLOCAL STATUS\thandleSdlcGf2(void);\r\nLOCAL STATUS\thandleSdlcGf3(void);\r\nLOCAL STATUS\thandleSdlcGf5(void);\r\nLOCAL STATUS\thandleSdlcGf6(void);\r\nLOCAL STATUS\thandleSdlcGf7(void);\r\nLOCAL STATUS\thandleSdlcGf8(void);\r\nLOCAL STATUS\thandleSdlcGf9(void);\r\nLOCAL STATUS\thandleSdlcGf11(void);\r\nLOCAL STATUS\thandleSdlcGf12(void);\r\n\r\nLOCAL int\t\tmtsCheckRange(double dLowerLimit,\r\n\t\t\t\t\t\t\t  double dUpperLimit, double dMeasure);\r\nLOCAL STATUS\tcalcNavData(void);\r\n\r\nLOCAL STATUS\tInitSdlcRecvGcu(SdlcRecvGcuInst *this) {\r\n\tthis->taskId = taskIdSelf();\r\n\tthis->state = STOP;\r\n\tthis->sidSdlcRx = SEM_ID_NULL;\r\n\t\r\n\tthis->ipcObj.msgQId = msgQCreate(SDLC_RECV_GCU_MSG_Q_LEN,\r\n\t\t\t\t\t\t\t\t\t sizeof(SdlcRecvGcuMsg), MSG_Q_FIFO);\r\n\tif (!(this->ipcObj.msgQId)) {\r\n\t\tLOGMSG(\"Message Q Creation Fail!\\n\");\r\n\t\treturn ERROR:\r\n\t}\r\n\t\r\n\tif (msgQEvStart(this->ipcObj.msgQId, SDLC_RECV_GCU_EVENT_CMD, 0)) {\r\n\t\tLOGMSG(\"msgQEvStart() error!\\n\");\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tif (axiSdlcGetRxSemaphore(SDLC_RECV_GCU_SDLC_CH, &this->sidSdlcRx) == ERROR) {\r\n\t\tLOGMSG(\"axiSdlcGetRxSemaphore(%d) error!\\n\", SDLC_RECV_GCU_SDLC_CH);\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tif ((this->sidSdlcRx != SEM_ID_NULL) &&\r\n\t\tsemEvStart(this->sidSdlcRx,\r\n\t\t\t\t   SDLC_RECV_GCU_EVENT_SDLC, EVENTS_SEND_IF_FREE)) {\r\n\t\tLOGMSG(\"semEvStart() error!\\n\");\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tg_tmGf2Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf2Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf3Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf3Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf5Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf5Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf6Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf6Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf7Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf7Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf8Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf8Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf9Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf9Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf11Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf11Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\tg_tmGf12Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\r\n\tg_tmGf12Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\r\n\t\r\n\tg_monNavLog.formatted.index.kind = LOG_SEND_INDEX_KIND_MTE_STS;\r\n\tg_monNavLog.formatted.index.id = LOG_SEND_INDEX_ID_MONITORING_NAV;\r\n\t\r\n\treturn OK;\r\n}\r\n\r\nLOCAL STATUS FinalizeSdlcRecvGcu(SdlcRecvGcuInst *this) {\r\n\tSTATUS nRet = OK;\r\n\t\r\n\tif (this->ipcObj.msgQId) {\r\n\t\tif (msgQEvStop(this->ipcObj.msgQId)) {\r\n\t\t\tLOGMSG(\"msgQEvStart() error!\\n\");\r\n\t\t\tnRet = ERROR;\r\n\t\t}\r\n\t\t\r\n\t\tif (msgQDelete(this->ipcObj.msgQId)) {\r\n\t\t\tLOGMSG(\"msgQDelete() error!\\n\");\r\n\t\t\tnRet = ERROR;\r\n\t\t} else {\r\n\t\t\tthis->ipcObj.msgQId = NULL;\r\n\t\t}\r\n\t}\r\n\t\r\n\tif ((this->sidSdlcRx != SEM_ID_NULL) && semEvStop(this->sidSdlcRx)) {\r\n\t\tLOGMSG(\"semEvStop() error!\\n\");\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\treturn nRet;\r\n}\r\n\r\nLOCAL STATUS ExecuteSdlcRecvGcu(SdlcRecvGcuInst *this) {\r\n\tSTATUS \t\tnRet = OK;\r\n\t_Vx_event_t\tevent;\r\n\t\r\n\tFOREVER {\r\n\t\tif (eventReceive(SDLC_RECV_GCU_EVENTS, EVENTS_WAIT_ANY,\r\n\t\t\t\t\t\t WAIT_FOREVER, &event) == ERROR) {\r\n\t\t\tLOGMSG(\"eventReceive() Error!\\n\");\r\n\t\t\tnRet = ERROR;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n#ifdef USE_CHK_TASK_STATUS\r\n\t\tupdateTaskStatus(this->taskStatus);\r\n#endif\r\n\t\tif (event & SDLC_RECV_GCU_EVENT_CMD) {\r\n\t\t\tif (procCommand(this) == ERROR)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\tif (event & SDLC_RECV_GCU_EVENT_SDLC) {\r\n\t\t\tprocSdlc(this);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn nRet;\r\n}\r\n\r\nLOCAL void OnStart(SdlcRecvGcuInst *this) {\r\n\tthis->state = RUNNING;\r\n}\r\n\r\nLOCAL void OnStop(SdlcRecvGcuInst *this) {\r\n\tthis->state = STOP;\r\n}\r\n\r\nLOCAL STATUS OnInitRxFrames(SdlcRecvGcuInst *this) {\r\n\tif (this->state == STOP)\r\n\t\treturn ERROR;\r\n\t\r\n\tmemset(g_pTmSdlcGfRx, 0x0, sizeof(TM_TYPE_SDLC_RX));\r\n\t\r\n\tmemset(g_pTmGf2, 0x0, sizeof(TM_TYPE_GF2));\r\n\tmemset(g_pTmGf3, 0x0, sizeof(TM_TYPE_GF3));\r\n\tmemset(g_pTmGf5, 0x0, sizeof(TM_TYPE_GF5));\r\n\tmemset(g_pTmGf6, 0x0, sizeof(TM_TYPE_GF6));\r\n\tmemset(g_pTmGf7, 0x0, sizeof(TM_TYPE_GF7));\r\n\tmemset(g_pTmGf8, 0x0, sizeof(TM_TYPE_GF8));\r\n\tmemset(g_pTmGf9, 0x0, sizeof(TM_TYPE_GF9));\r\n\tmemset(g_pTmGf11, 0x0, sizeof(TM_TYPE_GF11));\r\n\tmemset(g_pTmGf12, 0x0, sizeof(TM_TYPE_GF12));\r\n\t\t\t\t\t\t \r\n\treturn OK;\r\n}\r\n\r\nLOCAL STATUS procCommand(SdlcRecvGcuInst *this) {\r\n\tSdlcRecvGcuMsg stMsg;\r\n\t\r\n\twhile (msgQReceive(this->ipcObj.msgQId, (char *)&stMsg, sizeof(stMsg),\r\n\t\t\t\t\t   NO_WAIT) != ERROR) {\r\n\t\tif (stMsg.cmd == SDLC_RECV_GCU_QUIT)\r\n\t\t\treturn ERROR;\r\n\t\t\r\n\t\tswitch (stMsg.cmd) {\r\n\t\t\tcase SDLC_RECV_GCU_START:\r\n\t\t\t\tOnStart(this);\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLC_RECV_GCU_STOP:\r\n\t\t\t\tOnStop(this);\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLC_RECV_GCU_INIT_RX_FRAMES:\r\n\t\t\t\tOnInitRxFrames(this);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn OK;\r\n}\r\n\r\nLOCAL STATUS procSdlc(SdlcRecvGcuInst *this) {\r\n\tif (this->state == STOP)\r\n\t\treturn ERROR;\r\n\t\r\n\tif (semTake(this->sidSdlcRx, NO_WAIT) == ERROR)\r\n\t\treturn ERROR;\r\n\t\r\n\tg_nSdlcRxSize = axiSdlcGetRxLen(SDLC_RECV_GCU_SDLC_CH);\r\n\tif (g_nSdlcRxSize > sizeof(TM_TYPE_SDLC_RX)) {\r\n\t\tLOGMSG(\"[%s] Invalid Rx. Size...(%d)\\n\",\r\n\t\t\t   SDLC_RECV_GCU_TASK_NAME, g_nSdlcRxSize);\r\n\t\t\t   \r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tconst void * restrict pAxiSdlcRxBuf = axiSdlcGetRxBuf(SDLC_RECV_GCU_SDLC_CH);\r\n\tif (pAxiSdlcRxBuf == NULL) {\r\n\t\tLOGMSG(\"Cannot Get SDLC Rx. Buffer...\\n\");\r\n\t\t\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tmemcpy(g_pTmSdlcGfRx, pAxiSdlcRxBuf, g_nSdlcRxSize);\r\n\t\r\n\tif (g_pTmSdlcGfRx->gf2.m_ADDRESS != TM_SDLC_ADDRESS) {\r\n\t\tg_pTmCommSts->wAddressErrCnt++;\r\n\t\t\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\thandleSdlcRxBuf();\r\n\t\r\n\treturn OK;\r\n}\r\n\r\nLOCAL void handleSdlcRxBuf(void){\r\n\tswitch (g_pTmSdlcGfRx->gf2.m_CONTROL) {\r\n\t\tcase TM_GF2_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF2)) {\r\n\t\t\t\thandleSdlcGf2();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf2SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\t\r\n\t\tcase TM_GF3_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF3)) {\r\n\t\t\t\thandleSdlcGf3();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf3SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF5_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF5)) {\r\n\t\t\t\thandleSdlcGf5();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf5SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF6_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF6)) {\r\n\t\t\t\thandleSdlcGf6();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf6SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF7_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF7)) {\r\n\t\t\t\thandleSdlcGf7();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf7SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF8_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF8)) {\r\n\t\t\t\thandleSdlcGf8();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf8SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF9_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF9)) {\r\n\t\t\t\thandleSdlcGf9();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf9SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF11_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF11)) {\r\n\t\t\t\thandleSdlcGf11();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf11SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase TM_GF12_SDLC_CONTROL:\r\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF12)) {\r\n\t\t\t\thandleSdlcGf12();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_pTmCommSts->wGf12SizeErrCnt++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tg_pTmCommSts->wControlErrCnt++;\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\nLOCAL void handleSdlcGf2(void) {\r\n\ttmSwapGf2();\r\n\t\r\n\tswitch (g_pTmGf2->m_GCU_RESP & 0xFF00) {\r\n\t\tcase TM_FG2_1_OPCODE_MODE_LAUNCH:\r\n\t\tcase TM_FG2_1_OPCODE_MODE_HILS:\r\n\t\tcase TM_FG2_1_OPCODE_MODE_TEST:\r\n\t\tcase TM_FG2_1_OPCODE_MODE_GCU_PROGRAM:\r\n\t\tcase TM_FG2_1_OPCODE_MSL_COMM_START:\r\n\t\tcase TM_FG2_1_OPCODE_MSL_START_GNC:\r\n\t\tcase TM_FG2_1_OPCODE_ACT_TEST_START:\r\n\t\tcase TM_FG2_1_OPCODE_ACT_TEST_END:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf21RxCnt++;\r\n\t\t\tbreak;\r\n\t\tcase TM_FG2_2_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf22RxCnt++;\r\n\t\t\tbreak;\r\n\t\tcase TM_FG2_2_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf22RxCnt++;\r\n\t\t\tbreak;\r\n\t\tcase TM_FG2_3_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf23RxCnt++;\r\n\t\t\tbreak;\r\n\t\tcase TM_FG2_4_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf24RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_FG2_1_OPCODE_MSL_MOTOR_ON:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf28RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tcase TM_FG2_2_OPCODE_MSL_LIFT_OFF_READY:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf29RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_FG3_1_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf2RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tdefault:\r\n\t\t\tg_pTmCommSts->wGf2OpCodeErrCnt++;\r\n\t\t\tbreak;\r\n\t}\r\n\t\r\n\tg_tmGf2Log.formatted.tickLog = tickGet();\r\n\tg_tmGf2Log.formatted.index.id = 0x20;\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf2Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF2) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL void handleSdlcGf3(void) {\r\n\ttmSwapGf3();\r\n\t\r\n\tswitch (g_pTmGf3->gf3_1.m_GCU_RESP & 0xFF00) {\r\n\t\tcase TM_TCS_GCU_RESP_CODE_GF3_1:\r\n\t\t\tg_tmGf3Log.formatted.index.id = 0x31;\r\n\t\t\tg_pTmCommSts->wGf3RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_GCU_RESP_CODE_GF3_2:\r\n\t\t\tg_tmGf3Log.formatted.index.id = 0x32;\r\n\t\t\tg_pTmCommSts->wGf3RxCnt++;\r\n\t\t\tbreak;\r\n\t\tcase TM_TCS_GCU_RESP_CODE_GF3_A:\r\n\t\tcase TM_TCS_GCU_RESP_CODE_GF3_B:\r\n\t\t\tg_tmGf3Log.formatted.index.id = 0x33;\r\n\t\t\tg_pTmCommSts->wGf3RxCnt++;\r\n\t\t\tbreak;\r\n\t\tcase TM_TCS_GCU_RESP_CODE_GF3_4:\r\n\t\t\tg_tmGf3Log.formatted.index.id = 0x34;\r\n\t\t\tg_pTmCommSts->wGf3RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tdefault:\r\n\t\t\tg_pTmCommSts->wGf3OpCodeErrCnt++;\r\n\t\t\tbreak;\r\n\t}\r\n\t\r\n\tg_tmGf3Log.formatted.tickLog = tickGet();\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf3Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF3) + OFFSET(LOG_DATA, formatted, body));\r\n}\r\n\r\nLOCAL void handleSdlcGf5(void) {\r\n\ttmSwapGf5();\r\n\t\r\n\tswitch (g_pTmGf5->m_MAR_RESP & 0xFF00) {\r\n\t\tcase TM_GF5_OPCODE:\r\n\t\tg_pTmCommSts->wGf5RxCnt++;\r\n\t\tg_tmGf5Log.formatted.index.id = 0x50;\r\n\t\tbreak;\r\n\t\t\r\n\t\tdefault:\r\n\t\t\tg_pTmCommSts->wGf5OpCodeErrCnt++;\r\n\t\t\tbreak;\r\n\t}\r\n\t\r\n\tg_tmGf5Log.formatted.ticklog = tickGet();\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf5Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF5) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL void handleSdlcGf6(void) {\r\n\ttmSwapGf6();\r\n\t\r\n\tswitch (g_pTmGf6->gf6_1.m_MAR_RESP & 0xFF00) {\r\n\t\tcase TM_GF6_1_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf6RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf61RxCnt++;\r\n\t\t\tg_tmGf6Log.formatted.index.id = 0x61;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tcase TM_GF6_2_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf6RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf62RxCnt++;\r\n\t\t\tg_tmGf6Log.formatted.index.id = 0x62;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tcase TM_GF6_3_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf6RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf63RxCnt++;\r\n\t\t\tg_tmGf6Log.formatted.index.id = 0x63;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tcase TM_GF6_4_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf6RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf64RxCnt++;\r\n\t\t\tg_tmGf6Log.formatted.index.id = 0x64;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_GF6_5_OPCODE:\r\n\t\t\tg_pTmCommSts->wGf6RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf65RxCnt++;\r\n\t\t\tg_tmGf6Log.formatted.index.id = 0x65;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tdefault:\r\n\t\t\tg_pTmCommSts->wGf60pCodeErrCnt++;\r\n\t\t\tbreak;\r\n\t}\r\n\t\r\n\tg_tmGf6Log.formatted.ticklog = tickGet();\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf6Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF5) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL void handleSdlcGf7(void) {\r\n\ttmSwapGf7();\r\n\t\r\n\tswitch (g_pTmGf7->m_NAV_RESP & 0xFF00) {\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_2;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf72RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_3;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf73RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_4;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf74RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_5;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf75RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_6;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf76RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_7;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf77RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_8;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf78RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase TM_TCS_INS_RESP_CODE_GF7_9;\r\n\t\t\tg_pTmCommSts->wGf7RxCnt++;\r\n\t\t\tg_pTmCommSts->wGf79RxCnt++;\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tdefault:\r\n\t\t\tg_pTmCommSts->wGf7OpCodeErrCnt++;\r\n\t\t\tbreak;\r\n\t}\r\n\t\r\n\tg_tmGf7Log.formatted.tickLog = tickGet();\r\n\tg_tmGf7Log.formatted.index.id = 0x70;\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf7Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF7) + OFFSET(LOG_DATA, formatted.body));\r\n\tif (calcNavData() == OK) {\r\n\t\tg_monNavLog.formatted.tickLog = tickGet();\r\n\t\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_monNavLog),\r\n\t\t\t\t\t\t sizeof(MonitoringNavLog) + OFFSET(LOG_DATA, formatted.body));\r\n\t}\r\n}\r\n\r\nLOCAL void handleSdlcGf8(void) {\r\n\ttmSwapGf8();\r\n\t\r\n\tg_pTmCommSts->wGf8RxCnt++;\r\n\t\r\n\tg_tmGf8Log.formatted.tickLog = tickGet();\r\n\tg_tmGf8Log.formatted.index.id = 0x80;\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf8Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF8) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL void handleSdlcGf9(void) {\r\n\ttmSwapGf9();\r\n\t\r\n\tg_pTmCommSts->wGf9RxCnt++;\r\n\t\r\n\tg_tmGf9Log.formatted.tickLog = tickGet();\r\n\tg_tmGf9Log.formatted.index.id = 0x90;\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf9Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF9) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL void handleSdlcGf11(void) {\r\n\ttmSwapGf11();\r\n\t\r\n\tg_pTmCommSts->wGf11RxCnt++;\r\n\t\r\n\tg_tmGf11Log.formatted.tickLog = tickGet();\r\n\tg_tmGf11Log.formatted.index.id = 0xB0;\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf11Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF11) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL void handleSdlcGf12(void) {\r\n\ttmSwapGf12();\r\n\t\r\n\tg_pTmCommSts->wGf12RxCnt++;\r\n\t\r\n\tg_tmGf12Log.formatted.tickLog = tickGet();\r\n\tg_tmGf12Log.formatted.index.id = 0xC0;\r\n\tPostLogSendCmdEx(LOG_SEND_TX, (const char *)(&g_tmGf12Log),\r\n\t\t\t\t\t sizeof(TM_TYPE_GF12) + OFFSET(LOG_DATA, formatted.body));\r\n}\r\n\r\nLOCAL int mtsCheckRange(double dLowerLimit, double dUpperLimit, double dMeasure) {\r\n\tint resultType = 0;\r\n\tif ((dMeasure >= dLowerLimit) && (dMeasure <= dUpperLimit)) {\r\n\t\tresultType = RESULT_TYPE_PASS;\r\n\t} else {\r\n\t\tresultType = RESULT_TYPE_FAIL;\r\n\t}\r\n\t\r\n\treturn resultType;\r\n}\r\n\r\nLOCAL STATUS calcNavData(void) {\r\n\tdouble latTemp, lonTemp, htTemp;\r\n\t\r\n\tif ((g_pTmGf7->m_NAV_STS & 0xF) == 0x4) {\r\n\t\tg_pMonNav->flightTime = g_pTmGf7->m_MODE_TIME;\r\n\t} else {\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tif (g_pMonNav->flightTime < 61) {\r\n\t\tg_pMonNav->ve60 = (double)(g_pTmGf7->m_AVE * 0.000025);\r\n\t\tg_pMonNav->vn60 = (double)(g_pTmGf7->m_AVN * 0.000025);\r\n\t\tg_pMonNav->vu60 = (double)(g_pTmGf7->m_AVU * 0.000025);\r\n\t\t\r\n\t\tlatTemp = fabs(((double)g_pTmGf7->m_ALAT) * 0.000000083819031754);\r\n\t\tg_pMonNav->errLat60 = (fabs(g_pTmFg3->fg3_1.mXLATL) - latTemp) * 111180;\r\n\t\t\r\n\t\tlonTemp = fabs(((double)g_pTmGf7->m_ALON) * 0.000000083819031754);\r\n\t\tg_pMonNav->errLon60 = (fabs(g_pTmFg3->fg3_1.mXLONL) - lonTemp) * 89165;\r\n\t\t\r\n\t\thtTemp = fabs(((double)g_pTmGf7->m_AHEIGHT) * 0.005);\r\n\t\tg_pMonNav->errHt60 = (fabs(g_pTmFg3->fg3_1.m_HL) - htTemp);\r\n\t\t\r\n\t\tg_pMonNav->sts60.bit.ve = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts60.bit.vn = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts60.bit.vu = RESULT_TYPE_ONGOING;\r\n\t\t\r\n\t\tg_pMonNav->sts60.bit.errLat = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts60.bit.errLon = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts60.bit.errHt = RESULT_TYPE_ONGOING;\r\n\t} else if (g_pMonNav->flightTime == 61) {\r\n\t\tg_pMonNav->sts60.bit.ve = mtsCheckRange(-NAV_VE_TOLERANCE, NAV_VE_TOLERANCE, g_pMonNav->ve60);\r\n\t\tg_pMonNav->sts60.bit.vn = mtsCheckRange(-NAV_VN_TOLERANCE, NAV_VN_TOLERANCE, g_pMonNav->vn60);\r\n\t\tg_pMonNav->sts60.bit.vu = mtsCheckRange(-NAV_VU_TOLERANCE, NAV_VU_TOLERANCE, g_pMonNav->vu60);\r\n\t\t\r\n\t\tg_pMonNav->sts60.bit.errLat = mtsCheckRange(-NAV_ALAT_TOLERANCE, NAV_ALAT_TOLERANCE, g_pMonNav->errLat60);\r\n\t\tg_pMonNav->sts60.bit.errLon = mtsCheckRange(-NAV_ALONG_TOLERANCE, NAV_ALONG_TOLERANCE, g_pMonNav->errLon60);\r\n\t\tg_pMonNav->sts60.bit.errHt = mtsCheckRange(-NAV_AHEIGHT_TOLERANCE, NAV_AHEIGHT_TOLERANCE, g_pMonNav->errHt60);\r\n\t} else if (g_pMonNav->flightTime > 61 && g_pMonNav->flightTime < 181) {\r\n\t\tg_pMonNav->ve180 = (double)(g_pTmGf7->m_AVE * 0.000025);\r\n\t\tg_pMonNav->vn180 = (double)(g_pTmGf7->m_AVN * 0.000025);\r\n\t\tg_pMonNav->vu180 = (double)(g_pTmGf7->m_AVU * 0.000025);\r\n\t\t\r\n\t\tlatTemp = fabs(((double)g_pTmGf7->m_ALAT) * 0.000000083819031754);\r\n\t\tg_pMonNav->errLat180 = (fabs(g_pTmFg3->fg3_1.m_XLATL) - latTemp) * 111180;\r\n\t\t\r\n\t\tlonTemp = fabs(((double)g_pTmGf7->m_ALON) * 0.000000083819031754);\r\n\t\tg_pMonNav->errLon180 = (fabs(g_pTmFg3->fg3_1.m_XLONL) - lonTemp) * 89165;\r\n\t\t\r\n\t\thtTemp =  fabs(((double)g_pTmGf7->m_AHEIGHT) * 0.005);\r\n\t\tg_pMonNav->errHt180 = (fabs(g_pTmFg3->fg3_1.m_HL) - htTemp);\r\n\t\t\r\n\t\tg_pMonNav->sts180.bit.ve = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts180.bit.vn = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts180.bit.vu = RESULT_TYPE_ONGOING;\r\n\t\t\r\n\t\tg_pMonNav->sts180.bit.errLat = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts180.bit.errLon = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts180.bit.errHt = RESULT_TYPE_ONGOING;\r\n\t} else if (g_pMonNav->flightTime == 181) {\r\n\t\tg_pMonNav->sts180.bit.ve = mtsCheckRange(-NAV_VE_TOLERANCE, NAV_VE_TOLERANCE, g_pMonNav->ve180);\r\n\t\tg_pMonNav->sts180.bit.vn = mtsCheckRange(-NAV_VN_TOLERANCE, NAV_VN_TOLERANCE, g_pMonNav->vn180);\r\n\t\tg_pMonNav->sts180.bit.vu = mtsCheckRange(-NAV_VU_TOLERANCE, NAV_VU_TOLERANCE, g_pMonNav->vu180);\r\n\t\t\r\n\t\tg_pMonNav->sts180.bit.errLat = mtsCheckRange(-NAV_ALAT_TOLERANCE, NAV_ALAT_TOLERANCE, g_pMonNav->errLat180);\r\n\t\tg_pMonNav->sts180.bit.errLon = mtsCheckRange(-NAV_ALONG_TOLERANCE, NAV_ALONG_TOLERANCE, g_pMonNav->errLon180);\r\n\t\tg_pMonNav->sts180.bit.errHt = mtsCheckRange(-NAV_AHEIGHT_TOLERANCE, NAV_AHEIGHT_TOLERANCE, g_pMonNav->errHt180);\r\n\t} else if (g_pMonNav->flightTime > 181 && g_pMonNav->flightTime < 301) {\r\n\t\tg_pMonNav->ve300 = (double)(g_pTmGf7->m_AVE * 0.000025);\r\n\t\tg_pMonNav->vn300 = (double)(g_pTmGf7->m_AVN * 0.000025);\r\n\t\tg_pMonNav->vu300 = (double)(g_pTmGf7->m_AVU * 0.000025);\r\n\t\t\r\n\t\tlatTemp = fabs(((double)g_pTmGf7->m_ALAT) * 0.000000083819031754);\r\n\t\tg_pMonNav->errLat300 = (fabs(g_pTmFg3->fg3_1.m_XLATL) - latTemp) * 111180;\r\n\t\t\r\n\t\tlonTemp = fabs(((double)g_pTmGf7->m_ALON) * 0.000000083819031754);\r\n\t\tg_pMonNav->errLon300 = (fabs(g_pTmFg3->fg3_1.m_XLATL) - lonTemp) * 89165;\r\n\t\t\r\n\t\thtTemp = fabs(((double)g_pTmGf7->m_AHEIGHT) * 0.0H);\r\n\t\tg_pMonNav->errHt300 = (fabs(g_pTmFg3->fg3_1.m_HL) - htTemp);\r\n\t\t\r\n\t\tg_pMonNav->sts300.bit.ve = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts300.bit.vn = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts300.bit.vu = RESULT_TYPE_ONGOING;\r\n\t\t\r\n\t\tg_pMonNav->sts300.bit.errLat = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts300.bit.errLon = RESULT_TYPE_ONGOING;\r\n\t\tg_pMonNav->sts300.bit.errHt = RESULT_TYPE_ONGOING;\r\n\t} else if (g_pMonNav->flightTime == 301) {\r\n\t\tg_pMonNav->sts300.bit.ve = mtsCheckRange(-NAV_VE_TOLERANCE, NAV_VE_TOLERANCE, g_pMonNav->ve300);\r\n\t\tg_pMonNav->sts300.bit.vn = mtsCheckRange(-NAV_VN_TOLERANCE, NAV_VN_TOLERANCE, g_pMonNav->vn300);\r\n\t\tg_pMonNav->sts300.bit.vu = mtsCheckRange(-NAV_VU_TOLERANCE, NAV_VU_TOLERANCE, g_pMonNav->vu300);\r\n\t\t\r\n\t\tg_pMonNav->sts300.bit.errLat = mtsCheckRange(-NAV_ALAT_TOLERANCE, NAV_ALAT_TOLERANCE, g_pMonNav->errLat300);\r\n\t\tg_pMonNav->sts300.bit.errLon = mtsCheckRange(-NAV_ALONG_TOLERANCE, NAV_ALONG_TOLERANCE, g_pMonNav->errLon300);\r\n\t\tg_pMonNav->sts300.bit.errHt = mtsCheckRange(-NAV_AHEIGHT_TOLERANCE, NAV_AHEIGHT_TOLERANCE, g_pMonNav->errHt300);\r\n\t} else {\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\treturn OK;\r\n}\r\n\r\nvoid SdlcRecvGcuMain(ModuleInst *pModuleInst) {\r\n\tSdlcRecvGcuInst *this = (SdlcRecvGcuInst *)pModuleInst;\r\n\t\r\n\tif (InitSdlcRecvGcu(this) == ERROR) {\r\n\t\tLOGMSG(\"InitSdlcRecvGcu() error!\\n\");\r\n\t} else if (ExecuteSdlcRecvGcu(this) == ERROR) {\r\n\t\tLOGMSG(\"ExecuteSdlcRecvGcu() error!!\\n\");\r\n\t}\r\n\tif (FinalizeSdlcRecvGcu(this) == ERROR) {\r\n\t\tLOGMSG(\"FinalizeSdlcRecvGcu() error!!\\n\");\r\n\t}\r\n}\n--- End of content ---"
    },
    {
      "id": "95e52a90-081e-4300-8da0-a097b23293e6",
      "timestamp": "2025-09-26T05:41:35.947Z",
      "type": "gemini",
      "content": "This document provides a detailed, block-by-block explanation of the C code in `SdlcRecvGcu.c`. This file appears to implement a module responsible for receiving and processing SDLC (Synchronous Data Link Control) messages from a GCU (Ground Control Unit), likely within a real-time operating system environment (e.g., VxWorks) given the use of `eventLib`, `msgQEvLib`, and `semEvLib`. It handles various types of received data frames (GF2, GF3, GF5, etc.) and performs navigation data calculations and logging.\n\n### Block 1: Preprocessor Directives and Includes\n\n```c\n#define DEBUG_MSG\n\n#include <eventLib.h>\n#include <msgQEvLib.h>\n#include <semEvLib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"../lib/util/isDebug.h\"\n#include \"../drv/axiSdlc.h\"\n#include \"typeDef/opsType.h\"\n#include \"common.h\"\n#include \"SdlcRecvGcu.h\"\n#include \"LogSend.h\"\n#include \"SdlcSwap.h\"\n#include \"tickLib.h\"\n#include \"Monitoring.h\"\n```\n\n*   **`#define DEBUG_MSG`**: This preprocessor directive defines a macro `DEBUG_MSG`. It's likely used for conditional compilation, where certain debug-related code blocks might be included or excluded based on whether this macro is defined.\n*   **`#include <eventLib.h>`**: Includes the header for event management, providing functions for creating, sending, and receiving events. This is a common feature in RTOS for inter-task communication and synchronization.\n*   **`#include <msgQEvLib.h>`**: Includes the header for message queue event library, which likely integrates message queues with the event library, allowing tasks to wait for messages using events.\n*   **`#include <semEvLib.h>`**: Includes the header for semaphore event library, integrating semaphores with the event library, enabling tasks to wait for semaphore availability using events.\n*   **`#include <string.h>`**: Standard C library for string manipulation functions like `memcpy` and `memset`.\n*   **`#include <math.h>`**: Standard C library for mathematical functions, specifically `fabs` used later for absolute values.\n*   **`#include \"../lib/util/isDebug.h\"`**: Includes a custom header for debugging utilities.\n*   **`#include \"../drv/axiSdlc.h\"`**: Includes the header for the AXI SDLC driver, suggesting interaction with a hardware SDLC controller.\n*   **`#include \"typeDef/opsType.h\"`**: Includes custom type definitions related to operations.\n*   **`#include \"common.h\"`**: Includes common definitions and utilities.\n*   **`#include \"SdlcRecvGcu.h\"`**: Includes the header file for this module, defining its public interface and data structures.\n*   **`#include \"LogSend.h\"`**: Includes the header for a logging mechanism, used to send formatted log messages.\n*   **`#include \"SdlcSwap.h\"`**: Includes a header for SDLC data swapping functions, likely for endianness conversion.\n*   **`#include \"tickLib.h\"`**: Includes a library for system tick management, used for timestamping logs.\n*   **`#include \"Monitoring.h\"`**: Includes a header related to system monitoring.\n\n### Block 2: Macro Definitions\n\n```c\n#define SDLC_RECV_GCU_MSG_Q_LEN\t\t(20)\n#define SDLC_RECV_GCU_EVENT_SDLC\t(VXEV01)\n#define SDLC_RECV_GCU_EVENT_CMD\t\t(VXEV02)\n#define SDLC_RECV_GCU_EVENTS \\\n\t(SDLC_RECV_GCU_EVENT_SDLC | SDLC_RECV_GCU_EVENT_CMD)\n\t\n#define NAV_VE_TOLERANCE\t\t\t(0.5)\n#define NAV_VN_TOLERANCE\t\t\t(0.5)\n#define NAV_VU_TOLERANCE\t\t\t(0.5)\n#define NAV_ALAT_TOLERANCE\t\t\t(30.0)\n#define NAV_ALONG_TOLERANCE\t\t\t(30.0)\n#define NAV_AHEIGHT_TOLERANCE\t\t(60.0)\n\n#define  SDLC_RECV_GCU_SDLC_CH\t\t(0)\n```\n\n*   **`SDLC_RECV_GCU_MSG_Q_LEN`**: Defines the maximum number of messages the message queue for this module can hold.\n*   **`SDLC_RECV_GCU_EVENT_SDLC`**: Defines an event flag (VXEV01) specifically for SDLC receive events. `VXEV01` is likely a VxWorks-specific event bit.\n*   **`SDLC_RECV_GCU_EVENT_CMD`**: Defines an event flag (VXEV02) for command messages received by this module.\n*   **`SDLC_RECV_GCU_EVENTS`**: A bitmask combining `SDLC_RECV_GCU_EVENT_SDLC` and `SDLC_RECV_GCU_EVENT_CMD`, used to wait for either event.\n*   **`NAV_VE_TOLERANCE`, `NAV_VN_TOLERANCE`, `NAV_VU_TOLERANCE`**: Define tolerance values for navigation velocity errors (East, North, Up).\n*   **`NAV_ALAT_TOLERANCE`, `NAV_ALONG_TOLERANCE`, `NAV_AHEIGHT_TOLERANCE`**: Define tolerance values for navigation position errors (Latitude, Longitude, Height).\n*   **`SDLC_RECV_GCU_SDLC_CH`**: Defines the SDLC channel number used by this module (channel 0).\n\n### Block 3: Type Definitions\n\n```c\ntypedef enum {\n\tRUNNING,\n\tSTOP\n} SdlcRecvGcuState;\n\ntypedef struct {\n\tTASK_ID\t\t\ttaskId;\n\tModuleType\t\tipcType;\n\tunion {\n\t\tMSG_Q_ID\tmsgQId;\n\t\tint\t\t\tpipeFd;\n\t\tint\t\t\tquitFlag;\n\t} ipcObj;\n\tchar\t\t\tdeferredWorkName[32];\n#ifdef USE_CHK_TASK_STATUS\n\tTaskStatus *\t\ttaskStatus;\n#endif\n\tSdlcRecvGcuState\tstate;\n\tSEM_ID\t\t\t\tsidSdlcRx;\n} SdlcRecvGcuInst;\n```\n\n*   **`SdlcRecvGcuState`**: An enumeration defining the possible states of the `SdlcRecvGcu` module: `RUNNING` and `STOP`.\n*   **`SdlcRecvGcuInst`**: A structure representing an instance of the `SdlcRecvGcu` module.\n    *   `taskId`: The ID of the task associated with this module instance.\n    *   `ipcType`: The type of Inter-Process Communication (IPC) used (e.g., message queue, pipe).\n    *   `ipcObj`: A union to hold the IPC object ID (either `msgQId` for message queue, `pipeFd` for pipe, or `quitFlag` for a simple quit mechanism).\n    *   `deferredWorkName`: A character array to store the name of deferred work (purpose not immediately clear without further context).\n    *   `taskStatus`: A pointer to a `TaskStatus` structure, conditionally compiled with `USE_CHK_TASK_STATUS`, likely for task health monitoring.\n    *   `state`: The current operational state of the module (`RUNNING` or `STOP`).\n    *   `sidSdlcRx`: The semaphore ID used for synchronizing SDLC receive operations.\n\n### Block 4: Global Variables\n\n```c\nLOCAL SdlcRecvGcuInst g_stSdlcRecvGcuInst = {\n\tTASK_ID_ERROR, MSGQ, {MSG_Q_ID_NULL}, \"\",\n};\n\nLOCAL TM_TYPE_SDLC_RX\tg_stSdlcRxBuf;\nLOCAL UINT32\t\t\tg_nSdlcRxSize;\n\nLOCAL LOG_DATA\t\t\tg_tmGf2Log;\nLOCAL LOG_DATA\t\t\tg_tmGf3Log;\nLOCAL LOG_DATA\t\t\tg_tmGf5Log;\nLOCAL LOG_DATA\t\t\tg_tmGf6Log;\nLOCAL LOG_DATA\t\t\tg_tmGf7Log;\nLOCAL LOG_DATA\t\t\tg_tmGf8Log;\nLOCAL LOG_DATA\t\t\tg_tmGf9Log;\nLOCAL LOG_DATA\t\t\tg_tmGf11Log;\nLOCAL LOG_DATA\t\t\tg_tmGf12Log;\n\nLOCAL LOG_DATA\t\t\tg_monNavLog;\n\nconst ModuleInst *g_hSdlcRecvGcu = (ModuleInst *)&g_stSdlcRecvGcuInst;\n\nTM_TYPE_SDLC_TX * g_pTmSdlcGfRx = &g_stSdlcRxBuf;\nTM_TYPE_GF2 * g_pTmGf2 = &g_tmGf2Log.formatted.body.sdlcRx.gf2;\nTM_TYPE_GF3 * g_pTmGf3 = &g_tmGf3Log.formatted.body.sdlcRx.gf3;\nTM_TYPE_GF5 * g_pTmGf5 = &g_tmGf5Log.formatted.body.sdlcRx.gf5;\nTM_TYPE_GF6 * g_pTmGf6 = &g_tmGf6Log.formatted.body.sdlcRx.gf6;\nTM_TYPE_GF7 * g_pTmGf7 = &g_tmGf7Log.formatted.body.sdlcRx.gf7;\nTM_TYPE_GF8 * g_pTmGf8 = &g_tmGf8Log.formatted.body.sdlcRx.gf8;\nTM_TYPE_GF8 * g_pTmGf9 = &g_tmGf9Log.formatted.body.sdlcRx.gf9;\nTM_TYPE_GF11 * g_pTmGf11 = &g_tmGf11Log.formatted.body.sdlcRx.gf11;\nTM_TYPE_GF12 * g_pTmGf12 = &g_tmGf12Log.formatted.body.sdlcRx.gf12;\n\nMonitoringNavLog * g_pMonNav = &g_monNavLog.formatted.body.monitoringNav;\n```\n\n*   **`g_stSdlcRecvGcuInst`**: A `LOCAL` (static to this file) instance of `SdlcRecvGcuInst`, initialized with default error values. This is the main instance of the SDLC receive module.\n*   **`g_stSdlcRxBuf`**: A `LOCAL` buffer of type `TM_TYPE_SDLC_RX` to store raw received SDLC data.\n*   **`g_nSdlcRxSize`**: A `LOCAL` `UINT32` variable to store the size of the received SDLC data.\n*   **`g_tmGfXLog` (for X = 2, 3, 5, 6, 7, 8, 9, 11, 12)**: `LOCAL` instances of `LOG_DATA` structures, each dedicated to logging specific types of SDLC General Format (GF) messages.\n*   **`g_monNavLog`**: A `LOCAL` `LOG_DATA` instance for logging navigation monitoring data.\n*   **`g_hSdlcRecvGcu`**: A `const` pointer to `ModuleInst`, pointing to the `g_stSdlcRecvGcuInst`. This provides a generic interface to the module instance.\n*   **`g_pTmSdlcGfRx`**: A pointer to `TM_TYPE_SDLC_TX`, initialized to point to `g_stSdlcRxBuf`. This seems to be a type mismatch (`_RX` vs `_TX`), which might be a bug or a specific design choice for data handling.\n*   **`g_pTmGfX` (for X = 2, 3, 5, 6, 7, 8, 9, 11, 12)**: Pointers to specific GF message structures within their respective `LOG_DATA` instances. These pointers provide direct access to the formatted SDLC data for processing.\n*   **`g_pMonNav`**: A pointer to `MonitoringNavLog`, pointing to the navigation monitoring data within `g_monNavLog`.\n\n### Block 5: Function Prototypes\n\n```c\nLOCAL STATUS\tInitSdlcRecvGcu(SdlcRecvGcuInst *this);\nLOCAL STATUS\tFinalizeSdlcRecvGcu(SdlcRecvGcuInst *this);\nLOCAL STATUS\tExecuteSdlcRecvGcu(SdlcRecvGcuInst *this);\n\nLOCAL void\t\tOnStart(SdlcRecvGcuInst *this);\nLOCAL void\t\tOnStop(SdlcRecvGcuInst *this);\nLOCAL STATUS\tOnInitRxFrames(SdlcRecvGcuInst *this);\n\nLOCAL STATUS \tprocCommand(SdlcRecvGcuInst *this);\nLOCAL STATUS\tprocSdlc(SdlcRecvGcuInst *this);\n\nLOCAL void handleSdlcRxBuf(void);\nLOCAL void handleSdlcGf2(void);\nLOCAL void handleSdlcGf3(void);\nLOCAL void handleSdlcGf5(void);\nLOCAL void handleSdlcGf6(void);\nLOCAL void handleSdlcGf7(void);\nLOCAL void handleSdlcGf8(void);\nLOCAL void handleSdlcGf9(void);\nLOCAL void handleSdlcGf11(void);\nLOCAL void handleSdlcGf12(void);\n\nLOCAL int\t\tmtsCheckRange(double dLowerLimit,\n\t\t\t\t\t\t\t  double dUpperLimit, double dMeasure);\nLOCAL STATUS\tcalcNavData(void);\n```\n\nThis block declares the prototypes for all `LOCAL` (static) functions within this file. These functions handle initialization, finalization, execution loop, state changes, command processing, SDLC data processing, and navigation data calculations.\n\n### Block 6: `InitSdlcRecvGcu` Function\n\n```c\nLOCAL STATUS\tInitSdlcRecvGcu(SdlcRecvGcuInst *this) {\n\tthis->taskId = taskIdSelf();\n\tthis->state = STOP;\n\tthis->sidSdlcRx = SEM_ID_NULL;\n\t\n\tthis->ipcObj.msgQId = msgQCreate(SDLC_RECV_GCU_MSG_Q_LEN,\n\t\t\t\t\t\t\t\t\t sizeof(SdlcRecvGcuMsg), MSG_Q_FIFO);\n\tif (!(this->ipcObj.msgQId)) {\n\t\tLOGMSG(\"Message Q Creation Fail!\\n\");\n\t\treturn ERROR:\n\t}\n\t\n\tif (msgQEvStart(this->ipcObj.msgQId, SDLC_RECV_GCU_EVENT_CMD, 0)) {\n\t\tLOGMSG(\"msgQEvStart() error!\\n\");\n\t\treturn ERROR;\n\t}\n\t\n\tif (axiSdlcGetRxSemaphore(SDLC_RECV_GCU_SDLC_CH, &this->sidSdlcRx) == ERROR) {\n\t\tLOGMSG(\"axiSdlcGetRxSemaphore(%d) error!\\n\", SDLC_RECV_GCU_SDLC_CH);\n\t\treturn ERROR;\n\t}\n\t\n\tif ((this->sidSdlcRx != SEM_ID_NULL) &&\n\t\tsemEvStart(this->sidSdlcRx,\n\t\t\t\t   SDLC_RECV_GCU_EVENT_SDLC, EVENTS_SEND_IF_FREE)) {\n\t\tLOGMSG(\"semEvStart() error!\\n\");\n\t\treturn ERROR;\n\t}\n\t\n\tg_tmGf2Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf2Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf3Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf3Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf5Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf5Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf6Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf6Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf7Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf7Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf8Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf8Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf9Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf9Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf11Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf11Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\tg_tmGf12Log.formatted.index.kind = LOG_SEND_INDEX_KIND_GCU;\n\tg_tmGf12Log.formatted.index.direction = LOG_SEND_INDEX_DIRECTION_RX;\n\t\n\tg_monNavLog.formatted.index.kind = LOG_SEND_INDEX_KIND_MTE_STS;\n\tg_monNavLog.formatted.index.id = LOG_SEND_INDEX_ID_MONITORING_NAV;\n\t\n\treturn OK;\n}\n```\n\n*   **C Aspects**: Function definition, pointer usage (`this`), structure member access (`->`), conditional statements (`if`), function calls (`taskIdSelf`, `msgQCreate`, `msgQEvStart`, `axiSdlcGetRxSemaphore`, `semEvStart`, `LOGMSG`), return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: Initializes the `SdlcRecvGcu` module instance.\n*   **Functionality**:\n    *   Sets the task ID to the current task's ID.\n    *   Initializes the module state to `STOP` and the SDLC receive semaphore to `SEM_ID_NULL`.\n    *   Creates a message queue (`msgQCreate`) for inter-task communication with a specified length and message size, configured as FIFO. Error handling is included.\n    *   Starts event notification for the message queue (`msgQEvStart`), associating it with `SDLC_RECV_GCU_EVENT_CMD`.\n    *   Obtains the SDLC receive semaphore from the AXI SDLC driver (`axiSdlcGetRxSemaphore`) for the specified channel.\n    *   Starts event notification for the SDLC receive semaphore (`semEvStart`), associating it with `SDLC_RECV_GCU_EVENT_SDLC` and configured to send events when the semaphore is free.\n    *   Initializes the `kind` and `direction` fields for all `g_tmGfXLog` log data structures to `LOG_SEND_INDEX_KIND_GCU` and `LOG_SEND_INDEX_DIRECTION_RX` respectively, indicating GCU received logs.\n    *   Initializes the `kind` and `id` fields for `g_monNavLog` to `LOG_SEND_INDEX_KIND_MTE_STS` and `LOG_SEND_INDEX_ID_MONITORING_NAV`.\n    *   Returns `OK` on success, `ERROR` on failure.\n\n### Block 7: `FinalizeSdlcRecvGcu` Function\n\n```c\nLOCAL STATUS FinalizeSdlcRecvGcu(SdlcRecvGcuInst *this) {\n\tSTATUS nRet = OK;\n\t\n\tif (this->ipcObj.msgQId) {\n\t\tif (msgQEvStop(this->ipcObj.msgQId)) {\n\t\t\tLOGMSG(\"msgQEvStart() error!\\n\");\n\t\t\tnRet = ERROR;\n\t\t}\n\t\t\n\t\tif (msgQDelete(this->ipcObj.msgQId)) {\n\t\t\tLOGMSG(\"msgQDelete() error!\\n\");\n\t\t\tnRet = ERROR;\n\t\t} else {\n\t\t\tthis->ipcObj.msgQId = NULL;\n\t\t}\n\t}\n\t\n\tif ((this->sidSdlcRx != SEM_ID_NULL) && semEvStop(this->sidSdlcRx)) {\n\t\tLOGMSG(\"semEvStop() error!\\n\");\n\t\treturn ERROR;\n\t}\n\t\n\treturn nRet;\n}\n```\n\n*   **C Aspects**: Function definition, pointer usage (`this`), conditional statements (`if`), function calls (`msgQEvStop`, `msgQDelete`, `semEvStop`, `LOGMSG`), return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: Finalizes and cleans up resources used by the `SdlcRecvGcu` module.\n*   **Functionality**:\n    *   If the message queue exists, it stops event notification for it (`msgQEvStop`) and then deletes the message queue (`msgQDelete`). Error handling is included.\n    *   If the SDLC receive semaphore exists, it stops event notification for it (`semEvStop`).\n    *   Returns `OK` if all finalization steps are successful, otherwise returns `ERROR`.\n\n### Block 8: `ExecuteSdlcRecvGcu` Function\n\n```c\nLOCAL STATUS ExecuteSdlcRecvGcu(SdlcRecvGcuInst *this) {\n\tSTATUS \t\tnRet = OK;\n\t_Vx_event_t\tevent;\n\t\n\tFOREVER {\n\t\tif (eventReceive(SDLC_RECV_GCU_EVENTS, EVENTS_WAIT_ANY,\n\t\t\t\t\t\t WAIT_FOREVER, &event) == ERROR) {\n\t\t\tLOGMSG(\"eventReceive() Error!\\n\");\n\t\t\tnRet = ERROR;\n\t\t\tbreak;\n\t\t}\n\n#ifdef USE_CHK_TASK_STATUS\n\t\tupdateTaskStatus(this->taskStatus);\n#endif\n\t\tif (event & SDLC_RECV_GCU_EVENT_CMD) {\n\t\t\tif (procCommand(this) == ERROR)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (event & SDLC_RECV_GCU_EVENT_SDLC) {\n\t\t\tprocSdlc(this);\n\t\t}\n\t}\n\t\n\treturn nRet;\n}\n```\n\n*   **C Aspects**: Function definition, pointer usage (`this`), local variables, `FOREVER` loop (macro for `while(1)`), conditional statements (`if`), bitwise operations (`&`), function calls (`eventReceive`, `updateTaskStatus`, `procCommand`, `procSdlc`, `LOGMSG`), return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: Implements the main execution loop of the `SdlcRecvGcu` task.\n*   **Functionality**:\n    *   Enters an infinite loop (`FOREVER`).\n    *   Waits for any of the defined events (`SDLC_RECV_GCU_EVENTS`) using `eventReceive`. It waits indefinitely (`WAIT_FOREVER`). If `eventReceive` returns `ERROR`, it logs an error and breaks the loop.\n    *   Conditionally updates the task status (`updateTaskStatus`) if `USE_CHK_TASK_STATUS` is defined.\n    *   If a command event (`SDLC_RECV_GCU_EVENT_CMD`) is received, it calls `procCommand` to process the command. If `procCommand` returns `ERROR`, it breaks the loop.\n    *   If an SDLC event (`SDLC_RECV_GCU_EVENT_SDLC`) is received, it calls `procSdlc` to process the SDLC data.\n    *   Returns `OK` if the loop exits gracefully (e.g., due to a quit command), otherwise `ERROR`.\n\n### Block 9: `OnStart`, `OnStop`, `OnInitRxFrames` Functions\n\n```c\nLOCAL void OnStart(SdlcRecvGcuInst *this) {\n\tthis->state = RUNNING;\n}\n\nLOCAL void OnStop(SdlcRecvGcuInst *this) {\n\tthis->state = STOP;\n}\n\nLOCAL STATUS OnInitRxFrames(SdlcRecvGcuInst *this) {\n\tif (this->state == STOP)\n\t\treturn ERROR;\n\t\n\tmemset(g_pTmSdlcGfRx, 0x0, sizeof(TM_TYPE_SDLC_RX));\n\t\n\tmemset(g_pTmGf2, 0x0, sizeof(TM_TYPE_GF2));\n\tmemset(g_pTmGf3, 0x0, sizeof(TM_TYPE_GF3));\n\tmemset(g_pTmGf5, 0x0, sizeof(TM_TYPE_GF5));\n\tmemset(g_pTmGf6, 0x0, sizeof(TM_TYPE_GF6));\n\tmemset(g_pTmGf7, 0x0, sizeof(TM_TYPE_GF7));\n\tmemset(g_pTmGf8, 0x0, sizeof(TM_TYPE_GF8));\n\tmemset(g_pTmGf9, 0x0, sizeof(TM_TYPE_GF9));\n\tmemset(g_pTmGf11, 0x0, sizeof(TM_TYPE_GF11));\n\tmemset(g_pTmGf12, 0x0, sizeof(TM_TYPE_GF12));\n\t\t\t\t\t\t \n\treturn OK;\n}\n```\n\n*   **C Aspects**: Function definitions, pointer usage (`this`), structure member access (`->`), conditional statements (`if`), function calls (`memset`), `sizeof` operator, return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: These functions manage the state of the module and initialize receive buffers.\n*   **Functionality**:\n    *   **`OnStart`**: Sets the module's state to `RUNNING`.\n    *   **`OnStop`**: Sets the module's state to `STOP`.\n    *   **`OnInitRxFrames`**:\n        *   Checks if the module is in the `STOP` state; if so, it returns `ERROR`.\n        *   Clears (sets to 0x0) the `g_pTmSdlcGfRx` buffer and all individual GF message buffers (`g_pTmGf2` through `g_pTmGf12`) using `memset`. This ensures that previous data is not carried over.\n        *   Returns `OK` on success, `ERROR` if the module is stopped.\n\n### Block 10: `procCommand` Function\n\n```c\nLOCAL STATUS procCommand(SdlcRecvGcuInst *this) {\n\tSdlcRecvGcuMsg stMsg;\n\t\n\twhile (msgQReceive(this->ipcObj.msgQId, (char *)&stMsg, sizeof(stMsg),\n\t\t\t\t\t   NO_WAIT) != ERROR) {\n\t\tif (stMsg.cmd == SDLC_RECV_GCU_QUIT)\n\t\t\treturn ERROR;\n\t\t\n\t\tswitch (stMsg.cmd) {\n\t\t\tcase SDLC_RECV_GCU_START:\n\t\t\t\tOnStart(this);\n\t\t\t\tbreak;\n\t\t\tcase SDLC_RECV_GCU_STOP:\n\t\t\t\tOnStop(this);\n\t\t\t\tbreak;\n\t\t\tcase SDLC_RECV_GCU_INIT_RX_FRAMES:\n\t\t\t\tOnInitRxFrames(this);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn OK;\n}\n```\n\n*   **C Aspects**: Function definition, pointer usage (`this`), local variables, `while` loop, conditional statements (`if`), `switch` statement, `case` labels, function calls (`msgQReceive`, `OnStart`, `OnStop`, `OnInitRxFrames`), `sizeof` operator, return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: Processes commands received via the message queue.\n*   **Functionality**:\n    *   Continuously attempts to receive messages from the module's message queue (`this->ipcObj.msgQId`) without waiting (`NO_WAIT`).\n    *   If a `SDLC_RECV_GCU_QUIT` command is received, it returns `ERROR`, signaling the task to terminate.\n    *   Uses a `switch` statement to handle different command types:\n        *   `SDLC_RECV_GCU_START`: Calls `OnStart` to set the module state to `RUNNING`.\n        *   `SDLC_RECV_GCU_STOP`: Calls `OnStop` to set the module state to `STOP`.\n        *   `SDLC_RECV_GCU_INIT_RX_FRAMES`: Calls `OnInitRxFrames` to clear receive buffers.\n    *   Returns `OK` after processing all available commands in the queue, or `ERROR` if a quit command is received.\n\n### Block 11: `procSdlc` Function\n\n```c\nLOCAL STATUS procSdlc(SdlcRecvGcuInst *this) {\n\tif (this->state == STOP)\n\t\treturn ERROR;\n\t\n\tif (semTake(this->sidSdlcRx, NO_WAIT) == ERROR)\n\t\treturn ERROR;\n\t\n\tg_nSdlcRxSize = axiSdlcGetRxLen(SDLC_RECV_GCU_SDLC_CH);\n\tif (g_nSdlcRxSize > sizeof(TM_TYPE_SDLC_RX)) {\n\t\tLOGMSG(\"[%s] Invalid Rx. Size...(%d)\\n\",\n\t\t\t   SDLC_RECV_GCU_TASK_NAME, g_nSdlcRxSize);\n\t\t\t   \n\t\treturn ERROR;\n\t}\n\t\n\tconst void * restrict pAxiSdlcRxBuf = axiSdlcGetRxBuf(SDLC_RECV_GCU_SDLC_CH);\n\tif (pAxiSdlcRxBuf == NULL) {\n\t\tLOGMSG(\"Cannot Get SDLC Rx. Buffer...\\n\");\n\t\t\n\t\treturn ERROR;\n\t}\n\t\n\tmemcpy(g_pTmSdlcGfRx, pAxiSdlcRxBuf, g_nSdlcRxSize);\n\t\n\tif (g_pTmSdlcGfRx->gf2.m_ADDRESS != TM_SDLC_ADDRESS) {\n\t\tg_pTmCommSts->wAddressErrCnt++;\n\t\t\n\t\treturn ERROR;\n\t}\n\t\n\thandleSdlcRxBuf();\n\t\n\treturn OK;\n}\n```\n\n*   **C Aspects**: Function definition, pointer usage (`this`, `pAxiSdlcRxBuf`), conditional statements (`if`), function calls (`semTake`, `axiSdlcGetRxLen`, `axiSdlcGetRxBuf`, `memcpy`, `handleSdlcRxBuf`, `LOGMSG`), `sizeof` operator, `restrict` keyword, structure member access (`->`), return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: Processes incoming SDLC data.\n*   **Functionality**:\n    *   Checks if the module is in the `STOP` state; if so, returns `ERROR`.\n    *   Attempts to take the SDLC receive semaphore (`semTake`) without waiting. If it fails, returns `ERROR`.\n    *   Gets the length of the received SDLC data from the AXI SDLC driver (`axiSdlcGetRxLen`).\n    *   Checks if the received size exceeds the maximum buffer size (`sizeof(TM_TYPE_SDLC_RX)`). If it does, logs an error and returns `ERROR`.\n    *   Gets a pointer to the received SDLC buffer from the AXI SDLC driver (`axiSdlcGetRxBuf`). If the pointer is `NULL`, logs an error and returns `ERROR`.\n    *   Copies the received data from the AXI SDLC buffer to `g_pTmSdlcGfRx` using `memcpy`.\n    *   Checks if the address in the received GF2 frame (`g_pTmSdlcGfRx->gf2.m_ADDRESS`) matches the expected `TM_SDLC_ADDRESS`. If not, increments an error counter and returns `ERROR`.\n    *   Calls `handleSdlcRxBuf` to further process the received SDLC buffer based on its content.\n    *   Returns `OK` on successful processing.\n\n### Block 12: `handleSdlcRxBuf` Function\n\n```c\nLOCAL void handleSdlcRxBuf(void){\n\tswitch (g_pTmSdlcGfRx->gf2.m_CONTROL) {\n\t\tcase TM_GF2_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF2)) {\n\t\t\t\thandleSdlcGf2();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf2SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase TM_GF3_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF3)) {\n\t\t\t\thandleSdlcGf3();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf3SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF5_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF5)) {\n\t\t\t\thandleSdlcGf5();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf5SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF6_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF6)) {\n\t\t\t\thandleSdlcGf6();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf6SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF7_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF7)) {\n\t\t\t\thandleSdlcGf7();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf7SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF8_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF8)) {\n\t\t\t\thandleSdlcGf8();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf8SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF9_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF9)) {\n\t\t\t\thandleSdlcGf9();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf9SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF11_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF11)) {\n\t\t\t\thandleSdlcGf11();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf11SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TM_GF12_SDLC_CONTROL:\n\t\t\tif (g_nSdlcRxSize == sizeof(TM_TYPE_GF12)) {\n\t\t\t\thandleSdlcGf12();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg_pTmCommSts->wGf12SizeErrCnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_pTmCommSts->wControlErrCnt++;\n\t\t\tbreak;\n\t}\n}\n```\n\n*   **C Aspects**: Function definition, `switch` statement, `case` labels, conditional statements (`if`), function calls (`handleSdlcGfX`), `sizeof` operator, structure member access (`->`).\n*   **Purpose**: Dispatches the received SDLC buffer to the appropriate handler function based on its control code.\n*   **Functionality**:\n    *   Uses a `switch` statement on `g_pTmSdlcGfRx->gf2.m_CONTROL` (the control field of the received SDLC frame) to determine the type of GF message.\n    *   For each `case` (e.g., `TM_GF2_SDLC_CONTROL`, `TM_GF3_SDLC_CONTROL`), it checks if `g_nSdlcRxSize` (the actual received size) matches the expected size for that GF type (`sizeof(TM_TYPE_GFX)`).\n    *   If the size matches, it calls the corresponding `handleSdlcGfX` function to process that specific GF message.\n    *   If the size does not match, it increments a size error counter for that GF type.\n    *   The `default` case handles unknown control codes by incrementing a general control error counter.\n\n### Block 13: `handleSdlcGfX` Functions (GF2, GF3, GF5, GF6, GF7, GF8, GF9, GF11, GF12)\n\nThese functions follow a similar pattern:\n1.  Call `tmSwapGfX()`: This function (defined in `SdlcSwap.h`) likely performs endianness swapping for the fields within the GF message structure to ensure correct interpretation.\n2.  Process the message based on its content (e.g., `m_GCU_RESP`, `m_MAR_RESP`, `m_NAV_RESP`). This often involves:\n    *   Incrementing various receive counters (`wGfXRxCnt`, `wGfXYRxCnt`).\n    *   Setting a specific `id` for the log entry (`g_tmGfXLog.formatted.index.id`).\n    *   Handling different opcodes or response codes within the message using a `switch` statement.\n    *   Incrementing error counters for unknown opcodes.\n3.  Record the current system tick (`tickGet()`) in the log structure (`g_tmGfXLog.formatted.tickLog`).\n4.  Post the formatted log data using `PostLogSendCmdEx`. This function (defined in `LogSend.h`) sends the log message for further processing or storage. The size argument includes the size of the GF message plus an offset to account for the `LOG_DATA` header.\n5.  `handleSdlcGf7` also includes a call to `calcNavData()` and, if successful, posts a navigation monitoring log.\n\n*   **C Aspects**: Function definitions, function calls (`tmSwapGfX`, `tickGet`, `PostLogSendCmdEx`, `calcNavData`), `switch` statement, `case` labels, bitwise operations (`&`), structure member access (`->`), `sizeof` operator, `OFFSET` macro.\n*   **Purpose**: To specifically process each type of General Format (GF) message received via SDLC.\n*   **Functionality**: Each `handleSdlcGfX` function is tailored to the structure and content of its respective GF message type. They perform data validation, update communication status counters, and log the received data.\n\n### Block 14: `mtsCheckRange` Function\n\n```c\nLOCAL int mtsCheckRange(double dLowerLimit, double dUpperLimit, double dMeasure) {\n\tint resultType = 0;\n\tif ((dMeasure >= dLowerLimit) && (dMeasure <= dUpperLimit)) {\n\t\tresultType = RESULT_TYPE_PASS;\n\t} else {\n\t\tresultType = RESULT_TYPE_FAIL;\n\t}\n\t\n\treturn resultType;\n}\n```\n\n*   **C Aspects**: Function definition, local variables, conditional statements (`if`, `else`), logical operators (`&&`, `>=` , `<=`), return values (`int`).\n*   **Purpose**: Checks if a measured double-precision floating-point value falls within a specified range.\n*   **Functionality**:\n    *   Takes a lower limit, an upper limit, and a measured value as input.\n    *   If the measured value is greater than or equal to the lower limit AND less than or equal to the upper limit, it sets `resultType` to `RESULT_TYPE_PASS`.\n    *   Otherwise, it sets `resultType` to `RESULT_TYPE_FAIL`.\n    *   Returns `resultType`.\n\n### Block 15: `calcNavData` Function\n\n```c\nLOCAL STATUS calcNavData(void) {\n\tdouble latTemp, lonTemp, htTemp;\n\t\n\tif ((g_pTmGf7->m_NAV_STS & 0xF) == 0x4) {\n\t\tg_pMonNav->flightTime = g_pTmGf7->m_MODE_TIME;\n\t} else {\n\t\treturn ERROR;\n\t}\n\t\n\tif (g_pMonNav->flightTime < 61) {\n\t\tg_pMonNav->ve60 = (double)(g_pTmGf7->m_AVE * 0.000025);\n\t\tg_pMonNav->vn60 = (double)(g_pTmGf7->m_AVN * 0.000025);\n\t\tg_pMonNav->vu60 = (double)(g_pTmGf7->m_AVU * 0.000025);\n\t\t\n\t\tlatTemp = fabs(((double)g_pTmGf7->m_ALAT) * 0.000000083819031754);\n\t\tg_pMonNav->errLat60 = (fabs(g_pTmFg3->fg3_1.mXLATL) - latTemp) * 111180;\n\t\t\n\t\tlonTemp = fabs(((double)g_pTmGf7->m_ALON) * 0.000000083819031754);\n\t\tg_pMonNav->errLon60 = (fabs(g_pTmFg3->fg3_1.mXLONL) - lonTemp) * 89165;\n\t\t\n\t\thtTemp = fabs(((double)g_pTmGf7->m_AHEIGHT) * 0.005);\n\t\tg_pMonNav->errHt60 = (fabs(g_pTmFg3->fg3_1.m_HL) - htTemp);\n\t\t\n\t\tg_pMonNav->sts60.bit.ve = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts60.bit.vn = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts60.bit.vu = RESULT_TYPE_ONGOING;\n\t\t\n\t\tg_pMonNav->sts60.bit.errLat = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts60.bit.errLon = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts60.bit.errHt = RESULT_TYPE_ONGOING;\n\t} else if (g_pMonNav->flightTime == 61) {\n\t\tg_pMonNav->sts60.bit.ve = mtsCheckRange(-NAV_VE_TOLERANCE, NAV_VE_TOLERANCE, g_pMonNav->ve60);\n\t\tg_pMonNav->sts60.bit.vn = mtsCheckRange(-NAV_VN_TOLERANCE, NAV_VN_TOLERANCE, g_pMonNav->vn60);\n\t\tg_pMonNav->sts60.bit.vu = mtsCheckRange(-NAV_VU_TOLERANCE, NAV_VU_TOLERANCE, g_pMonNav->vu60);\n\t\t\n\t\tg_pMonNav->sts60.bit.errLat = mtsCheckRange(-NAV_ALAT_TOLERANCE, NAV_ALAT_TOLERANCE, g_pMonNav->errLat60);\n\t\tg_pMonNav->sts60.bit.errLon = mtsCheckRange(-NAV_ALONG_TOLERANCE, NAV_ALONG_TOLERANCE, g_pMonNav->errLon60);\n\t\tg_pMonNav->sts60.bit.errHt = mtsCheckRange(-NAV_AHEIGHT_TOLERANCE, NAV_AHEIGHT_TOLERANCE, g_pMonNav->errHt60);\n\t} else if (g_pMonNav->flightTime > 61 && g_pMonNav->flightTime < 181) {\n\t\tg_pMonNav->ve180 = (double)(g_pTmGf7->m_AVE * 0.000025);\n\t\tg_pMonNav->vn180 = (double)(g_pTmGf7->m_AVN * 0.000025);\n\t\tg_pMonNav->vu180 = (double)(g_pTmGf7->m_AVU * 0.000025);\n\t\t\n\t\tlatTemp = fabs(((double)g_pTmGf7->m_ALAT) * 0.000000083819031754);\n\t\tg_pMonNav->errLat180 = (fabs(g_pTmFg3->fg3_1.m_XLATL) - latTemp) * 111180;\n\t\t\n\t\tlonTemp = fabs(((double)g_pTmGf7->m_ALON) * 0.000000083819031754);\n\t\tg_pMonNav->errLon180 = (fabs(g_pTmFg3->fg3_1.m_XLONL) - lonTemp) * 89165;\n\t\t\n\t\thtTemp =  fabs(((double)g_pTmGf7->m_AHEIGHT) * 0.005);\\r\\n\\t\\tg_pMonNav->errHt180 = (fabs(g_pTmFg3->fg3_1.m_HL) - htTemp);\n\t\t\n\t\tg_pMonNav->sts180.bit.ve = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts180.bit.vn = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts180.bit.vu = RESULT_TYPE_ONGOING;\n\t\t\n\t\tg_pMonNav->sts180.bit.errLat = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts180.bit.errLon = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts180.bit.errHt = RESULT_TYPE_ONGOING;\n\t} else if (g_pMonNav->flightTime == 181) {\n\t\tg_pMonNav->sts180.bit.ve = mtsCheckRange(-NAV_VE_TOLERANCE, NAV_VE_TOLERANCE, g_pMonNav->ve180);\n\t\tg_pMonNav->sts180.bit.vn = mtsCheckRange(-NAV_VN_TOLERANCE, NAV_VN_TOLERANCE, g_pMonNav->vn180);\n\t\tg_pMonNav->sts180.bit.vu = mtsCheckRange(-NAV_VU_TOLERANCE, NAV_VU_TOLERANCE, g_pMonNav->vu180);\n\t\t\n\t\tg_pMonNav->sts180.bit.errLat = mtsCheckRange(-NAV_ALAT_TOLERANCE, NAV_ALAT_TOLERANCE, g_pMonNav->errLat180);\n\t\tg_pMonNav->sts180.bit.errLon = mtsCheckRange(-NAV_ALONG_TOLERANCE, NAV_ALONG_TOLERANCE, g_pMonNav->errLon180);\n\t\tg_pMonNav->sts180.bit.errHt = mtsCheckRange(-NAV_AHEIGHT_TOLERANCE, NAV_AHEIGHT_TOLERANCE, g_pMonNav->errHt180);\n\t} else if (g_pMonNav->flightTime > 181 && g_pMonNav->flightTime < 301) {\n\t\tg_pMonNav->ve300 = (double)(g_pTmGf7->m_AVE * 0.000025);\n\t\tg_pMonNav->vn300 = (double)(g_pTmGf7->m_AVN * 0.000025);\n\t\tg_pMonNav->vu300 = (double)(g_pTmGf7->m_AVU * 0.000025);\n\t\t\n\t\tlatTemp = fabs(((double)g_pTmGf7->m_ALAT) * 0.000000083819031754);\n\t\tg_pMonNav->errLat300 = (fabs(g_pTmFg3->fg3_1.m_XLATL) - latTemp) * 111180;\n\t\t\n\t\tlonTemp = fabs(((double)g_pTmGf7->m_ALON) * 0.000000083819031754);\n\t\tg_pMonNav->errLon300 = (fabs(g_pTmFg3->fg3_1.m_XLATL) - lonTemp) * 89165;\n\t\t\n\t\thtTemp = fabs(((double)g_pTmGf7->m_AHEIGHT) * 0.0H);\n\t\tg_pMonNav->errHt300 = (fabs(g_pTmFg3->fg3_1.m_HL) - htTemp);\n\t\t\n\t\tg_pMonNav->sts300.bit.ve = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts300.bit.vn = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts300.bit.vu = RESULT_TYPE_ONGOING;\n\t\t\n\t\tg_pMonNav->sts300.bit.errLat = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts300.bit.errLon = RESULT_TYPE_ONGOING;\n\t\tg_pMonNav->sts300.bit.errHt = RESULT_TYPE_ONGOING;\n\t} else if (g_pMonNav->flightTime == 301) {\n\t\tg_pMonNav->sts300.bit.ve = mtsCheckRange(-NAV_VE_TOLERANCE, NAV_VE_TOLERANCE, g_pMonNav->ve300);\n\t\tg_pMonNav->sts300.bit.vn = mtsCheckRange(-NAV_VN_TOLERANCE, NAV_VN_TOLERANCE, g_pMonNav->vn300);\n\t\tg_pMonNav->sts300.bit.vu = mtsCheckRange(-NAV_VU_TOLERANCE, NAV_VU_TOLERANCE, g_pMonNav->vu300);\n\t\t\n\t\tg_pMonNav->sts300.bit.errLat = mtsCheckRange(-NAV_ALAT_TOLERANCE, NAV_ALAT_TOLERANCE, g_pMonNav->errLat300);\n\t\tg_pMonNav->sts300.bit.errLon = mtsCheckRange(-NAV_ALONG_TOLERANCE, NAV_ALONG_TOLERANCE, g_pMonNav->errLon300);\n\t\tg_pMonNav->sts300.bit.errHt = mtsCheckRange(-NAV_AHEIGHT_TOLERANCE, NAV_AHEIGHT_TOLERANCE, g_pMonNav->errHt300);\n\t} else {\n\t\treturn ERROR;\n\t}\n\t\n\treturn OK;\n}\n```\n\n*   **C Aspects**: Function definition, local variables (`double`), conditional statements (`if`, `else if`, `else`), bitwise operations (`&`), type casting (`(double)`), arithmetic operations, function calls (`fabs`, `mtsCheckRange`), structure member access (`->`, `.bit`), return values (`STATUS`, `OK`, `ERROR`).\n*   **Purpose**: Calculates and evaluates navigation data based on received GF7 messages at different flight time intervals.\n*   **Functionality**:\n    *   First, it checks the `m_NAV_STS` field of the `g_pTmGf7` message. If the lower 4 bits are `0x4`, it updates `g_pMonNav->flightTime` with `g_pTmGf7->m_MODE_TIME`. Otherwise, it returns `ERROR`.\n    *   It then proceeds with a series of `if-else if` blocks based on `g_pMonNav->flightTime` to perform calculations and range checks for different flight phases (e.g., `< 61` seconds, `== 61` seconds, `> 61` and `< 181` seconds, etc.).\n    *   **For ongoing phases (`< 61`, `> 61 && < 181`, `> 181 && < 301`):**\n        *   Calculates East, North, and Up velocities (`ve`, `vn`, `vu`) by scaling values from `g_pTmGf7`.\n        *   Calculates latitude, longitude, and height errors (`errLat`, `errLon`, `errHt`) using `fabs` and scaling factors, comparing values from `g_pTmGf7` and `g_pTmFg3`.\n        *   Sets the status bits for these parameters (`stsX.bit.ve`, `stsX.bit.vn`, etc.) to `RESULT_TYPE_ONGOING`.\n    *   **For specific time points (`== 61`, `== 181`, `== 301`):**\n        *   Calls `mtsCheckRange` to evaluate if the calculated navigation parameters (velocities and errors) fall within their defined tolerance limits (`NAV_VE_TOLERANCE`, `NAV_ALAT_TOLERANCE`, etc.).\n        *   Updates the status bits (`stsX.bit.ve`, `stsX.bit.vn`, etc.) with the result of `mtsCheckRange` (`RESULT_TYPE_PASS` or `RESULT_TYPE_FAIL`).\n    *   If `flightTime` falls outside the defined ranges, it returns `ERROR`.\n    *   Returns `OK` on successful calculation and evaluation.\n\n### Block 16: `SdlcRecvGcuMain` Function\n\n```c\nvoid SdlcRecvGcuMain(ModuleInst *pModuleInst) {\n\tSdlcRecvGcuInst *this = (SdlcRecvGcuInst *)pModuleInst;\n\t\n\tif (InitSdlcRecvGcu(this) == ERROR) {\n\t\tLOGMSG(\"InitSdlcRecvGcu() error!\\n\");\n\t} else if (ExecuteSdlcRecvGcu(this) == ERROR) {\n\t\tLOGMSG(\"ExecuteSdlcRecuGcu() error!!\\n\");\n\t}\n\tif (FinalizeSdlcRecvGcu(this) == ERROR) {\n\t\tLOGMSG(\"FinalizeSdlcRecvGcu() error!!\\n\");\n\t}\n}\n```\n\n*   **C Aspects**: Function definition, pointer usage (`pModuleInst`, `this`), type casting (`(SdlcRecvGcuInst *)`), conditional statements (`if`, `else if`), function calls (`InitSdlcRecvGcu`, `ExecuteSdlcRecvGcu`, `FinalizeSdlcRecvGcu`, `LOGMSG`).\n*   **Purpose**: The entry point for the `SdlcRecvGcu` module task.\n*   **Functionality**:\n    *   Casts the generic `ModuleInst` pointer to a `SdlcRecvGcuInst` pointer.\n    *   Calls `InitSdlcRecvGcu` to initialize the module. If initialization fails, it logs an error.\n    *   If initialization is successful, it calls `ExecuteSdlcRecvGcu` to start the main processing loop. If execution fails, it logs an error.\n    *   Finally, it calls `FinalizeSdlcRecvGcu` to clean up resources. If finalization fails, it logs an error.\n    *   This function orchestrates the lifecycle of the `SdlcRecvGcu` module.\n",
      "thoughts": [
        {
          "subject": "Begin Comprehension",
          "description": "I've initiated the reading of `mtsc/app/SdlcRec vGcu.c`. I am now generating a detailed breakdown, section-by-section. It'll emulate the style of the provided `Monitoring.md` example, with block-level C code annotations. I will describe the operations within and the purpose of the operations, for each significant block of code.",
          "timestamp": "2025-09-26T05:39:32.352Z"
        },
        {
          "subject": "Refining the Approach",
          "description": "I'm now fully immersed in the coding, breaking down `SdlcRec vGcu.c`. I've moved past mere section identification and am actively annotating each block of C code. The aim is to mirror the clarity and detail of the `Monitoring.md` example. I'm taking special care to document the function of each C aspect. I'll soon move to organizing all the information into a suitable markdown format.",
          "timestamp": "2025-09-26T05:39:33.515Z"
        },
        {
          "subject": "Beginning Analysis of Code",
          "description": "I've just finished reading `SdlcRecvGcu.c`. My next step is to compose the explanation and save it as `SdlcRecvGcu.md`.",
          "timestamp": "2025-09-26T05:39:36.476Z"
        }
      ],
      "tokens": {
        "input": 35942,
        "output": 27932,
        "cached": 20690,
        "thoughts": 40,
        "tool": 0,
        "total": 63914
      },
      "model": "gemini-2.5-flash"
    }
  ]
}